# -*- coding: utf-8 -*-
"""Tugas Pertemuan 5 KSI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S99BojxwFVjVCtBhLEUaCDs1i19mc4LH
"""

## PROGRAM TRANSPOSITION CHIPER

import math

def main():
  text = input("Masukkan Pesan : ")                               # Menerima inputan pesan dari pengguna
  key = int(input("Masukkan Kunci [2-%s]: " % (len(text) -1)))    # Menerima inputan kunci dari pengguna, dengan memberikan permintan bahwa kuncih harus di antara rentang karena jika tidak berada rentang, maka sama saja pesan tidak dienkripsi
  if( key < 2) or (key > len(text) -1):                           # Memeriksa apakah kunci sesuai dengan rentang
    print("\nWARNING : Silahkan masukkan kunci dalam rentang !")  # Memberikan pesan error karena kunci tidak sesuai dengan rentang
  else :
    mode = input("Enkripsi/Dekripsi [1/2]: ")                     # Menerima input jenis tindakan yang akan dilakukan pengguna
    if(mode.lower() == "1"):
      result = encryptionMessage(key, text)                       # Memanggil fungsi untuk enkripsi
    elif (mode.lower() == "2"):
      result = decrypteMessage(key, text)                         # Memanggil fungsi untuk dekripsi
    print ("\nHasil : \n%s" % (result + "|"))                     # Menampilkan hasil dari enkripsi atau dekripsi, ditambahkan karakter | pada akhir string untuk melihat apakah terdapat spasi di paling belakang


def encryptionMessage(key, message):                              # Mendefinisikan fungsi enkripsi
  chiperText = [""] * key                                         # Menyiapkan array untuk menyimpan hasil enkripsi, dimana array nya sebanyak kunci (Untuk setiap array akan menyimpan huruf dalam satu kolom)
  for col in range(key):                                          # Melakuakn perulangan dari 0 sampai dengan key (key akan menentukan berapa jumlah kolom)
    pointer = col                                                 # Inisiasi pointer
    while pointer < len(message):                                 # Ketika pointer masih dalam rentang panjagn pesan,
      chiperText[col] += message[pointer]                         # maka pesan akan diambil dan disimpan dalam array dari kolom yang bersankutan
      pointer += key                                              # Pointer bergerak dalam kelipatan key
  return "".join(chiperText)                                      # Menggabungkan huruf dari setiap  array yang terbentuk

def decrypteMessage(key, message):                                # Mendefinisikan fungsi dekripsi
  numCols = math.ceil(len(message) / key)                         # Menentukan jumlah kolum dimana merupakan pembulatan ke atas dari panajang pesan di bagi key
  numRows = key                                                   # Inisiasi jumlah baris sebanyak key
  numShadedBoxes  = (numCols * numRows) - len(message)            # Menentukan jumlah sel yang akan kosong
  plainText = [""] * numCols                                      # Inisasi array sebanyak kolum  untuk menyimpan hasil dekripsi
  col = 0                                                         # Inisasi awal col dan row, dari 0
  row = 0
  for karakter in message:                                        # Untuk setiap karakter di teks
    plainText[col] += karakter                                    # Karakter akan disusun ke samping dalam tabel
    col += 1

    if(col == numCols) or (col == numCols -1) and (row >= numRows - numShadedBoxes):
      col = 0   # apabila kolum sudah sampai ujung, atau sudah sampai pada kolom yang seharusnya tidak terisi, maka akan berpindah ke baris berikutnya
      row += 1
  return "".join(plainText)                                      # Menggabungkan huruf dari setiap  array yang terbentuk

main()                                                           # Memangil fungsi main

"""Program di atas merupakan rogram enkripsi dan deskripsi untuk transposition (Matrix baris dan kolumn). Adapun cara kerja dari algoritma di atas adalah sebagai berikut :
1.   Algoritrma Enkripsi

      *   Key akan menjadi jumlah kolumn
      *   Menyiapkan array sebanyak kolumn
      *   Menentukan start iterasi, lalu mengambil huruf dengan kelipatan jumlah kolom dan disimpan suatu array. Contoh : misalkan ada tiga kolom, array pertama menyimpan huruf indexs ke 0, 3, 6, dst; array kedua menyimpan huruf index ke 1, 4, 7, dst, array ketiga menyimpan huruf index ke 2, 5, 8, dst.
      *   Menggabungkan huruf yang tersimpan di masing-masing array dari indexs array terkecil

2.   Algoritma dekripsi

      *   Berkebalikan dengan enskripsi, key dalam dekripsi akan dijadikan sebagai jumlah baris, sedangkan jumlah kolom adalah hasil pembulatan ke atas dari pembagian panjang pesan dan key.
      *   Menentukan jumlah sel yang akan kosong, yaitu dari seluruh jumlah sel yang terbentuk di kurangi panjang huruf
      *   Melakukan perulangan untuk setiap  karakter, menyimpan karakter berurutan untuk setiap kolom. Baris akan berpindah apabila kolom dalam satu baris sudah penuh, atau jika kolom masih tersisa satu, tapi baris lebih dari sama dengan jumlah sel yang kosong.
      *   Setelah karakter habis, gabungkan array yang menyimpan huruf dalam satu kolom dari index terkecil.


Baik untuk algoritma enkripsi dan dekripsi di atas, memiliki kompleksitas O(n+k). Hal ini disebabkan karena hal berikut.
  1. Iterasi melalui setiap karakter dalam pesan membutuhkan waktu O(n), di mana n adalah panjang pesan.
  2. Dalam iterasi, kita mengumpulkan karakter-karakter dalam array kolom, yang memiliki ukuran tetap sesuai dengan jumlah kolom. Oleh karena itu, mengumpulkan karakter-karakter ini dalam array kolom membutuhkan waktu konstan
  3. Menggabungkan hasil dari array kolom menjadi satu string membutuhkan waktu O(k), di mana k adalah kunci.







"""

# PROGRAM CHIPER SUBSTITUTION RESHUFULLE ALPHABET

import random
alphabet = 'abcdefghijklmnopqrstuvwxyz'

def makeKey(alphabet):
   alphabet = list(alphabet)
   random.shuffle(alphabet)
   return ''.join(alphabet)

def encrypt(plaintext, key, alphabet):
    keyMap = dict(zip(alphabet, key))
    return ''.join(keyMap.get(c.lower(), c) for c in plaintext)

def decrypt(cipher, key, alphabet):
    keyMap = dict(zip(key, alphabet))
    return ''.join(keyMap.get(c.lower(), c) for c in cipher)

def main():
  text = input("Masukkan Pesan : ")
  mode = input("Enkripsi/Dekripsi [1/2]: ")
  if(mode.lower() == "1"):
    key = makeKey(alphabet)
    result = encrypt(text, key, alphabet)
  elif (mode.lower() == "2"):
    key = (input("Masukkan KuncI: "))
    result = decrypt(text, key, alphabet)
  print ("\nKey   : %s" % key)
  print ("\nHasil : \n%s" % (result + "|"))   # Menampilkan hasil dari enkripsi atau dekripsi, ditambahkan karakter | pada akhir string untuk melihat apakah terdapat spasi di paling belakang

main()

"""Program di atas merupakan program enkripsi dan dekripsi untku algoritma substitution dimana key yang diberikan adalah huruf pengganti dari setiap alphabet. algortima dari program di atas adalah



1.   Algoritma Enkripsi

    *   Membuat peta kunci dengan menggunakan fungsi zip() untuk menggabungkan setiap huruf dalam alphabet dengan huruf yang sesuai dalam key. Fungsi zip() membuat pasangan nilai dari alphabet dan key, dan fungsi dict() digunakan untuk mengonversi pasangan nilai ini menjadi  dictionary. Dictionary ini berisi pasangan nilai dengan huruf dari alphabet sebagai kunci dan huruf dari key sebagai nilai.

    *   Lalu menggunakan enkripsi generator untuk menghasilkan karakter-karakter hasi enkripsi. Dimana setiap karakter plain text diambil satu persatu, lalu mengambil nilai dari dictionary berdasarkan key (karakter dari plain text), jika karakter bukan huruf  maka akan dipertahankan.
    *   Menggabungkan setiap hasil enkripsi karakter dengan menggunakan join.

2.   Algoritma Dekripsi

    *   Algoritma sama dengan enkripsi, hanya saja untuk membuat dictionary peta kunci, yang menjadi key adalah key, sedangkan value nya adalah alphaber asli.  



Kedua algoritma di atas melakukan iterasi melalui setiap karakter dalam teks yang diberikan, dan operasi-operasi yang dilakukan di dalam loop tersebut (seperti dict(zip(...)), get(), lower(), join(), dan operasi untuk mengakses elemen dalam kamus) memerlukan waktu konstan. Jumlah iterasi dalam loop sesuai dengan panjang teks yang diberikan, sehingga kompleksitasnya bergantung pada panjang teks tersebut.

Oleh karena itu, baik untuk enkripsi maupun dekripsi, kompleksitasnya adalah O(n), di mana n adalah panjang dari teks yang dienkripsi atau didekripsi.

"""

# PROGRAM CAESAR CHIPPPER SUBSTITUION

def encrypt(text,s):                                        # Mendefisnikan fungsi enkripsi
    result = ""                                             # Inisiasi string untuk menyimpan hasil enkripsi
    for i in range(len(text)):
        char = text[i]
        if (char.isupper()):
            result += chr((ord(char) + s-65) % 26 + 65)     # Jika karakter merupakan huruf kapital, ubah dalam kode ASCII, geser sebasar s dan disesuaikan kembali untku tetap dalam rentang kode huruf kapital
        elif (char.islower()):
            result += chr((ord(char) + s - 97) % 26 + 97)   # Jika karakter merupakan huruf kecil, ubah dalam kode ASCII, geser sebasar s dan disesuaikan kembali untku tetap dalam rentang kode huruf kecil
        else:
            result += char                                  # jika spasi maka biarkan tetap spasi
    return result

def decrypt(text, s):
    result = ""
    for i in range(len(text)):
        char = text[i]
        if char.isupper():
            result += chr((ord(char) - s - 65) % 26 + 65)   # Jika karakter merupakan huruf kapital, ubah dalam kode ASCII, geser sebasar s ke bawah dan disesuaikan kembali untku tetap dalam rentang kode huruf kapital
        elif (char.islower()):
            result += chr((ord(char) - s - 97) % 26 + 97)   # Jika karakter merupakan huruf kecil, ubah dalam kode ASCII, geser sebasar s ke bawah dan disesuaikan kembali untku tetap dalam rentang kode huruf kecil
        else:
            result += char                                  # jika spasi biarkan tetap spasi
    return result

def main():
  text = input("Masukkan Pesan : ")
  key = int(input("Masukkan Kunci (shift): "))
  mode = input("Enkripsi/Dekripsi [1/2]: ")
  if(mode.lower() == "1"):
    result = encrypt(text, key)
  elif (mode.lower() == "2"):
    result = decrypt(text, key)
  print ("\nHasil : \n%s" % (result + "|"))                 # Menampilkan hasil dari enkripsi atau dekripsi, ditambahkan karakter | pada akhir string untuk melihat apakah terdapat spasi di paling belakang

main()

"""Program di atas merupakan program enkripsi dan dekripsi untuk algoritma caesar subsitution. adapun cara kerja algoritma di atas adaalh sebagai berikut


1.   Algoritma Enkripsi

      *   Perulangan dilakukan untuk setiap karakter
      *   Karakter akan di cek apakah merupakan huruf kapital, kecil, atau spasi. Jika huruf kapital, huruf akan digeser atau ditambah sebanayk shift (s) dan akan dikembalikan untuk tetap di rentang 0 - 26 dalam konteks huruf kapital (disesuaikan kode ASCII nya dengan ditambah 65). Jika huruf kecil, huruf akan digeser atau ditambah sebanyak shift (s) dan akan dikembalikan untuk tetap di rentang 0 - 26 dalam konteks huruf kecil (disesuaikan kode ASCII nya dengan ditambah 97). Jika spasi, akan dibarkan untuk tetap menjadi spasi.
       *   Untuk setiap karakter yang sudah di ditambah, masukan ke dalam variabel string result.


2.   Algoritma Dekripsi
      *   Perulangan dilakukan untuk setiap karakter
      *   Karakter akan di cek apakah merupakan huruf kapital, kecil, atau spasi. Jika huruf kapital, huruf akan  dikurangi sebanayk shift (s) dan akan dikembalikan untuk tetap di rentang 0 - 26 dalam konteks huruf kapital (disesuaikan kode ASCII nya dengan ditambah 65). Jika huruf kecil, huruf akan dikurangi sebanyak shift (s) dan akan dikembalikan untuk tetap di rentang 0 - 26 dalam konteks huruf kecil (disesuaikan kode ASCII nya dengan ditambah 97). Jika spasi, akan dibarkan untuk tetap menjadi spasi.
       *   Untuk setiap karakter yang sudah di ditambah, masukan ke dalam variabel string result.
       
Baik fungsi encrypt maupun decrypt melalui setiap karakter dalam teks, dan operasi-operasi yang dilakukan di dalam loop tersebut (seperti ord, chr, dan operasi aritmatika) memerlukan waktu konstan. Jumlah iterasi dalam loop sesuai dengan panjang teks yang diberikan, sehingga kompleksitasnya bergantung pada panjang teks tersebut.

Oleh karena itu, baik untuk enkripsi maupun dekripsi, kompleksitasnya adalah O(n), di mana n adalah panjang dari teks yang dienkripsi atau didekripsi.


"""